{"hash":"764270c9cde89f2821682f29cb99e4f3fffdc351","data":{"markdownPage":{"id":"c9e874d6515623ddf07f96c922e50aa9","title":"Internet lecture system","description":"","path":"/example-scenario/online-lecture/","timeToRead":13,"content":"<h1 id=\"internet-lecture-system\"><a href=\"#internet-lecture-system\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Internet lecture system</h1>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79727114-d3956280-8326-11ea-8862-e01ca9a0f949.png\" alt=\"image\"></p>\n<p>source: <a href=\"https://github.com/msa-ez/example-academy\" target=\"_blank\" class=\"link-open-text\">https://github.com/msa-ez/example-academy</a></p>\n<h2> Final group assignment - Internet lecture system</h2>\n<ul>\n<li>Checkpoint : <a href=\"https://workflowy.com/s/assessment-check-po/T5YrzcMewfo4J6LW\" target=\"_blank\" class=\"link-open-text\">https://workflowy.com/s/assessment-check-po/T5YrzcMewfo4J6LW</a></li>\n</ul>\n<h2 id=\"service-scenario\"><a href=\"#service-scenario\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>service scenario</h2>\n<h3>Udemy, Learning Portal</h3>\n<p><strong>Functional Requirements</strong><br>\n1. The student selects a course and registers for the course<br>\n2. The student pays<br>\n3. When the course registration is completed, the course registration details are transmitted to the instructor's lecture system<br>\n4. The student cancels the course registration<br>\n5. Course registration If this is canceled, the payment will be canceled<br>\n6. Instructor opens a course<br>\n7. Instructor cancels an established course<br>\n8. If the instructor cancels a course, the student's course registration is canceled<br>\n9. The student inquires the course registration details<br>\n10. Instructor inquires the number of lectures<br></p>\n<p><strong>Non-functional requirements</strong><br>\n1. Transaction<br></p>\n<ul>\n<li>\n<ol>\n<li>Course registration without payment should not be completed at all. Sync call<br></li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>\n<p>Disability isolation<br></p>\n<ul>\n<li>\n<ol>\n<li>Course registration should be available 24 hours a day, 365 days a year even if the course management function is not performed Async (event-driven), Eventual Consistency<br></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>When the payment system is overloaded, it induces users to make payments after a while without receiving any payments Circuit breaker, fallback<br></li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>Performance<br></p>\n<ul>\n<li>\n<ol>\n<li>Students take course registration contents that can be checked in the course management Must be able to check in the application system (front-end) CQRS<br></li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"checkpoint\"><a href=\"#checkpoint\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>checkpoint</h2>\n<ul>\n<li>analytical design</li>\n<li>\n<p>Event Storming:</p>\n<ul>\n<li>Do you properly understand the meaning of each sticker color object and properly reflect it in the design in connection with the hexagonal architecture?</li>\n<li>Is each domain event defined at a meaningful level?</li>\n<li>Aggregation: Are Commands and Events properly grouped into ACID transaction unit Aggregate?</li>\n<li>Are functional and non-functional requirements reflected without omission?</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>\n<p>Separation of subdomains, bounded contexts</p>\n<ul>\n<li>\n<p>Is the sub-domain or Bounded Context properly separated according to the team's KPIs, interests, and different distribution cycles, and is the rationality of the separation criteria sufficiently explained?</p>\n<ul>\n<li>Separation of at least 3 services</li>\n</ul>\n</li>\n<li>Polyglot design: Have you designed each microservice by adopting various technology stack and storage structures according to the implementation goals and functional characteristics of each microservice?</li>\n<li>In the service scenario, for the use case where the ACID transaction is critical, is the service not excessively and densely separated?</li>\n</ul>\n</li>\n<li>\n<p>Context Mapping / Event Driven Architecture</p>\n<ul>\n<li>Can you distinguish between task importance and hierarchy between domains? (Core, Supporting, General Domain)</li>\n<li>Can the request-response method and event-driven method be designed separately?</li>\n<li>Fault Isolation: Is it designed so that the existing service is not affected even if the supporting service is removed?</li>\n<li>Can it be designed (open architecture) so that the database of existing services is not affected when new services are added?</li>\n<li>Is the Correlation-key connection properly designed to link events and policies?</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>\n<p>Hexagonal Architecture</p>\n<ul>\n<li>Did you draw the hexagonal architecture diagram according to the design result correctly?</li>\n</ul>\n</li>\n<li>\n<p>avatar</p>\n<ul>\n<li>\n<p>[DDD] Was the implementation developed to be mapped according to the color of each sticker and the hexagonal architecture in the analysis stage?</p>\n<ul>\n<li>Have you developed a data access adapter through JPA by applying Entity Pattern and Repository Pattern?</li>\n<li>[Hexagonal Architecture] In addition to the REST inbound adapter, is it possible to adapt the existing implementation to a new protocol without damaging the domain model by adding an inbound adapter such as gRPC?</li>\n<li>Is the source code described using the ubiquitous language (terms used in the workplace) in the analysis stage?</li>\n</ul>\n</li>\n<li>\n<p>Implementation of service-oriented architecture of Request-Response method</p>\n<ul>\n<li>How did you find and call the target service in the Request-Response call between microservices? (Service Discovery, REST, FeignClient)</li>\n<li>Is it possible to isolate failures through circuit breakers?</li>\n</ul>\n</li>\n<li>\n<p>Implementing an event-driven architecture</p>\n<ul>\n<li>Are more than one service linked with PubSub using Kafka?</li>\n<li>Correlation-key: When each event (message) processes which policy, is the Correlation-key connection properly implemented to distinguish which event is connected to which event?</li>\n<li>Does the Message Consumer microservice receive and process existing events that were not received in the event of a failure?</li>\n<li>Scaling-out: Is it possible to receive events without duplicates when a replica of the Message Consumer microservice is added?</li>\n<li>CQRS: By implementing Materialized View, is it possible to configure the screen of my service and view it frequently without accessing the data source of other microservices (without Composite service or join SQL, etc.)?</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>\n<p>polyglot programming</p>\n<ul>\n<li>Are each microservices composed of one or more separate technology stacks?</li>\n<li>Did each microservice autonomously adopt its own storage structure and implement it by selecting its own storage type (RDB, NoSQL, File System, etc.)?</li>\n</ul>\n</li>\n<li>\n<p>API Gateway</p>\n<ul>\n<li>Can the point of entry of microservices be unified through API GW?</li>\n<li>Is it possible to secure microservices through gateway, authentication server (OAuth), and JWT token authentication?</li>\n</ul>\n</li>\n<li>\n<p>operation</p>\n<ul>\n<li>\n<p>SLA Compliance</p>\n<ul>\n<li>Self-Healing: Through the Liveness Probe, as the health status of any service continuously deteriorates, at what threshold can you prove that the pod is regenerated?</li>\n<li>Can fault isolation and performance efficiency be improved through circuit breaker and ray limit?</li>\n<li>Is it possible to set up an autoscaler (HPA) for scalable operation?</li>\n<li>Monitoring, alerting:</li>\n</ul>\n</li>\n<li>\n<p>Nonstop Operation CI/CD (10)</p>\n<ul>\n<li>When the new version is fully serviceable through the setting of the Readiness Probe and rolling update, it is proved by siege that the service is converted to the new version of the service.</li>\n<li>Contract Test: Is it possible to prevent implementation errors or API contract violations in advance through automated boundary testing?</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"analysisdesign\"><a href=\"#analysisdesign\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Analysis/Design</h2>\n<h3> - TO-BE Organization (Vertically-Aligned)</h3>\n<h3 id=\"-event-storming-result\"><a href=\"#-event-storming-result\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>· Event Storming result</h3>\n<p><strong>Derivation of organization and requirements</strong>\n<img src=\"https://user-images.githubusercontent.com/48303857/79729383-5cfa6400-832a-11ea-89b6-53eca4de1ab8.jpeg\" alt=\"image\"></p>\n<p><strong>Evoking events, attaching actor commands, aggregating, binding to bounded contexts</strong>\n<img src=\"https://user-images.githubusercontent.com/48303857/79729452-74d1e800-832a-11ea-9b08-0d2807c69a28.jpeg\" alt=\"image\"></p>\n<ul>\n<li>\n<p>domain sequence separation </p>\n<ul>\n<li>Core Domain: Course registration (front), course management: This is a core service, and the annual up-time SLA level is set at 99.999%, and the distribution cycle is less than once a week for course registration and less than once a month for course management. </li>\n<li>Supporting Domain: Dashboard: This is a service for competitiveness, and the SLA level is 60% or more per year uptime goal, and the distribution cycle is autonomous by each team, but the standard sprint cycle is one week, so it is based on at least once a week. </li>\n<li>General Domain: Payment: It is highly competitive to use a 3rd party external service as a payment service (to be converted to pink later)</li>\n</ul>\n</li>\n</ul>\n<p><strong>Attach the polish</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79729649-b4003900-832a-11ea-875f-c0e8dfc6ccb4.jpeg\" alt=\"image\"></p>\n<p><strong>Policy movement and context mapping (Pub/Sub for Blue, Req/Resp for Orange)</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79729705-c67a7280-832a-11ea-828f-fc0cc5510e17.jpeg\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79729768-d72ae880-832a-11ea-9900-8e0e0e281d87.jpeg\" alt=\"image\"></p>\n<p><strong>Completed first model</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79729946-15c0a300-832b-11ea-8247-4e261f22690d.jpeg\" alt=\"image\"></p>\n<ul>\n<li>Add View Model</li>\n</ul>\n<p><strong>Verification that functional/non-functional requirements for the first complete version are covered</strong></p>\n<ul>\n<li>The student selects a course and registers for the course (ok)</li>\n<li>Students pay (ok -sync)</li>\n<li>When a course is registered, course registration details are transmitted to the instructor's lecture system (ok - event driven)</li>\n<li>The student cancels the course registration (ok)</li>\n<li>If the course registration is canceled, the payment will be canceled (ok)</li>\n<li>The instructor opens the lecture (ok)</li>\n<li>The instructor cancels the opened course (ok)</li>\n<li>If the instructor cancels the course, the student's course registration will be canceled (ok)</li>\n<li>The student inquires the course registration details (view)</li>\n<li>Instructor inquires the number of lectures (view)</li>\n</ul>\n<p><strong>Modeled to cover requirements in a first-order model</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79814397-17d14300-83b9-11ea-8c7e-3517658dff13.png\" alt=\"image\"></p>\n<ul>\n<li>Payment processing when registering for lectures: Since the service must provide the benefit of the instructor who provides the lecture, the request-response method is used for payment processing when registering for courses.</li>\n<li>The lecture management function has a strong aspect of providing services, and since several students register for courses at one time, the course management service is handled in Async (event-driven) and Eventual Consistency methods. .</li>\n<li>When the payment system is overloaded, it induces users to make payments after a while without receiving users for a while. Using a circuit breaker</li>\n<li>Students must be able to check the course registration details that can be checked in the course management in the course registration system (front-end) CQRS</li>\n<li>Inter-microservice transactions excluding payment: For all events, it is judged that the timing of data consistency is not critical for all events, so Eventual Consistency is adopted as the default.\n</li>\n</ul>\n<h3 id=\"-hexagonal-architecture-diagram-derivation\"><a href=\"#-hexagonal-architecture-diagram-derivation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>· Hexagonal Architecture Diagram Derivation</h3>\n<p><img src=\"https://user-images.githubusercontent.com/63028469/79846797-d3b26280-83f9-11ea-9ad7-a7e6b4bea18e.png\" alt=\"image\"></p>\n<ul>\n<li>Distinguish between inbound adapter and outbound adapter by referring to Chris Richardson, MSA Patterns</li>\n<li>Distinguish between PubSub and Req/Resp in the call relationship</li>\n<li>Separation of sub-domains and bounded contexts: Each team's KPIs share their interest implementation stories as follows</li>\n</ul>\n<h2 id=\"avatar\"><a href=\"#avatar\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>avatar</h2>\n<p>According to the hexagonal architecture derived from the analysis/design phase, microservices represented by each BC were implemented with Spring Boot. The method to run each implemented service locally is as follows (each port number is 8081 ~ 808n)</p>\n<pre class=\"language-text\"><code class=\"language-text\">cd courseRegistrationSystem\nmvn spring-boot:run\n\ncd paymentSystem\nmvn spring-boot:run \n\ncd lectureSystem\nmvn spring-boot:run  </code></pre>\n<h3 id=\"-application-of-ddd\"><a href=\"#-application-of-ddd\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>· Application of DDD</h3>\n<ul>\n<li>The core Aggregate Root object derived from each service is declared as an Entity: (Example: paymentSystem microservice). In this case, the language (ubiquitous language) used in the field was used as it is possible. Since the English language was completed during modeling, there was no significant hindrance to development as it is.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">package skademy;\n\nimport javax.persistence.*;\nimport org.springframework.beans.BeanUtils;\nimport java.util.List;\n\n@Entity\n@Table(name=&quot;PaymentSystem_table&quot;)\npublic class PaymentSystem {\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.AUTO)\n    private Long id;\n    private Long courseId;\n\n    @PostPersist\n    public void onPostPersist(){\n        try {\n            Thread.currentThread().sleep((long) (400 + Math.random() * 220));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        PaymentCompleted paymentCompleted = new PaymentCompleted();\n        BeanUtils.copyProperties(this, paymentCompleted);\n        paymentCompleted.publish();\n    }\n\n    @PostRemove\n    public void onPostRemove(){\n        PaymentCanceled paymentCanceled = new PaymentCanceled();\n        BeanUtils.copyProperties(this, paymentCanceled);\n        paymentCanceled.publish();\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n    public Long getCourseId() {\n        return courseId;\n    }\n\n    public void setCourseId(Long courseId) {\n        this.courseId = courseId;\n    }\n}</code></pre>\n<ul>\n<li>By applying Entity Pattern and Repository Pattern, RestRepository of Spring Data REST was applied to automatically create a data access adapter so that there is no separate processing for various data source types (RDB) through JPA.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">package skademy;\n\nimport org.springframework.data.repository.PagingAndSortingRepository;\n\npublic interface PaymentSystemRepository extends PagingAndSortingRepository&lt;PaymentSystem, Long&gt;{\n}</code></pre>\n<ul>\n<li>Testing of REST API after application</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># courseRegistrationSystem Service registration processing\nhttp POST localhost:8081/courseRegistrationSystem lectureId=1</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79857038-272bad00-8408-11ea-8096-7f54b482ea54.png\" alt=\"image\"></p>\n<pre class=\"language-text\"><code class=\"language-text\"># Check order status\nhttp localhost:8081/courseRegistrationSystem</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79857153-4d514d00-8408-11ea-83be-cf9e002c9ce5.png\" alt=\"image\"></p>\n<h3 id=\"-synchronous-invocation-and-fallback-handling\"><a href=\"#-synchronous-invocation-and-fallback-handling\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>· Synchronous Invocation and Fallback Handling</h3>\n<p>As one of the conditions in the analysis phase, the call between course registration (courseRegistrationSystem) -> payment (paymentSystem) was decided to be processed as a transaction that maintains synchronous consistency. The calling protocol allows the REST service already exposed by the Rest Repository to be called using FeignClient. </p>\n<ul>\n<li>Implement service proxy interface (Proxy) using stub and (FeignClient) to call payment service  </li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># (courseRegistrationSystem) PaymentService.java\n\n@FeignClient(name =&quot;paymentSystems&quot;, url=&quot;http://52.231.118.204:8080&quot;)\npublic interface PaymentService {\n    @RequestMapping(method = RequestMethod.POST, value = &quot;/paymentSystems&quot;, consumes = &quot;application/json&quot;)\n    void makePayment(PaymentSystem paymentSystem);\n\n}</code></pre>\n<ul>\n<li>Process to request payment immediately after course registration (@PostPersist)</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">#CourseRegistrationSystem.java (Entity)\n\n    @PostPersist\n    public void onPostPersist(){\n        CourseRegistered courseRegistered = new CourseRegistered();\n        BeanUtils.copyProperties(this, courseRegistered);\n        courseRegistered.publish();\n\n        this.setLectureId(courseRegistered.getLectureId());\n        this.setStudentId(12334);\n        this.setStatus(&quot;Applying for courses&quot;);\n\n        System.out.println(&quot;##### POST CourseRegistrationSystem Enrolment : &quot; + this);\n\n        //Following code causes dependency to external APIs\n        // it is NOT A GOOD PRACTICE. instead, Event-Policy mapping is recommended.\n\n        PaymentSystem paymentSystem = new PaymentSystem();\n        paymentSystem.setCourseId(this.id);\n        // mappings goes here\n\n        //start payment\n        PaymentService paymentService = Application.applicationContext.getBean(PaymentService.class);\n        paymentService.makePayment(paymentSystem);\n\n    }</code></pre>\n<ul>\n<li>In synchronous calls, time coupling occurs with the time of the call, and confirming that if the payment system fails, the order is not taken:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># Put down paymentSystem for a while\n\n#Course registration processing\nhttp POST localhost:8081/courseRegistrationSystem lectureId=1   #Fail\nhttp POST localhost:8081/courseRegistrationSystem lectureId=2   #Fail</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79857341-9a352380-8408-11ea-908a-d776d192bb8e.png\" alt=\"image\"></p>\n<pre class=\"language-text\"><code class=\"language-text\">#Restart payment service\ncd paymentSystem\nmvn spring-boot:run\n\n#Course registration processing\nhttp POST localhost:8081/courseRegistrationSystem lectureId=1   #Success\nhttp POST localhost:8081/courseRegistrationSystem lectureId=2   #Success</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79857434-c05ac380-8408-11ea-88d4-8a6ce4af0100.png\" alt=\"image\"></p>\n<ul>\n<li>In addition, service failures can occur like dominoes in case of excessive requests. (Circuit breaker and fallback processing will be explained in the operation phase.)</li>\n</ul>\n<h3 id=\"-asynchronous-invocation--temporal-decoupling--failure-isolation--eventual-consistency-test\"><a href=\"#-asynchronous-invocation--temporal-decoupling--failure-isolation--eventual-consistency-test\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>· Asynchronous Invocation / Temporal Decoupling / Failure Isolation / Eventual Consistency Test</h3>\n<p>After the payment has been made, the act of notifying the course registration system is handled asynchronously, not synchronously, so that payment is not blocked in order to complete the course registration process.</p>\n<ul>\n<li>To this end, after leaving a record in the payment system, a domain event indicating that the payment has been completed is immediately sent to Kafka (Publish).</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">...\n    @PostPersist\n    public void onPostPersist(){\n   \n        PaymentCompleted paymentCompleted = new PaymentCompleted();\n        BeanUtils.copyProperties(this, paymentCompleted);\n        paymentCompleted.publish();\n    }</code></pre>\n<ul>\n<li>The course registration service implements PolicyHandler to receive the payment completion event and process its own policy.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">public class PolicyHandler{\n ...\n    \n    @StreamListener(KafkaProcessor.INPUT)\n    public void wheneverPaymentCompleted_EnrollmentComplete(@Payload PaymentCompleted paymentCompleted){\n        try {\n            if (paymentCompleted.isMe()) {\n                System.out.println(&quot;##### listener EnrollmentComplete : &quot; + paymentCompleted.toJson());\n                Optional&lt;CourseRegistrationSystem&gt; courseRegistrationSystemOptional = courseRegistrationSystemRepository.findById(paymentCompleted.getCourseId());\n                CourseRegistrationSystem courseRegistrationSystem = courseRegistrationSystemOptional.get();\n                courseRegistrationSystem.setStatus(&quot;Payment finished&quot;);\n                courseRegistrationSystem.setStudentId(courseRegistrationSystem.getStudentId());\n\n                courseRegistrationSystemRepository.save(courseRegistrationSystem);\n            }\n        }catch(Exception e) {\n\n        }\n    }</code></pre>\n<p>Since the course system is completely separate from registration/payment and is processed according to the reception of events, there is no problem receiving course registration even if the course system is temporarily down due to maintenance:</p>\n<pre class=\"language-text\"><code class=\"language-text\"># Put down the lecture service (lectureSystem) for a while\n\n#Course registration processing\nhttp POST localhost:8081/courseRegistrationSystem lectureId=1   #Success\nhttp POST localhost:8081/courseRegistrationSystem lectureId=2   #Success</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79857884-6d354080-8409-11ea-9307-02288463bb13.PNG\" alt=\"image\"></p>\n<pre class=\"language-text\"><code class=\"language-text\">#Check the event progress until the course registration is complete</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79857914-79b99900-8409-11ea-8658-030267f42214.PNG\" alt=\"image\"></p>\n<pre class=\"language-text\"><code class=\"language-text\">#Lecture service start\ncd lectureSystem\nmvn spring-boot:run\n\n# Check class attendance update\nCheck in the console window</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/48303857/79857956-8f2ec300-8409-11ea-98dd-2dd3667855b5.PNG\" alt=\"image\"></p>\n<h2 id=\"operation\"><a href=\"#operation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>operation</h2>\n<h3 id=\"-cicd-settings\"><a href=\"#-cicd-settings\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>· CI/CD settings</h3>\n<p>Each implementation was configured in their own source repository, the CI/CD platform used was Azure, and the pipeline build script was included in azure-pipeline.yml under each project folder.</p>\n<ul>\n<li>A pipeline was constructed using devops, and CI CD automation was implemented.\n<img src=\"https://user-images.githubusercontent.com/18453570/79851343-2262fb00-8400-11ea-85e9-b4627f9a6d0d.PNG\" alt=\"image\"></li>\n<li>It was confirmed that the pod was uploaded normally as shown below.\n<img src=\"https://user-images.githubusercontent.com/18453570/79851342-21ca6480-8400-11ea-914a-e80e14ea93c7.PNG\" alt=\"image\"></li>\n<li>You can see that they are all registered as services in Kubernetes as shown below.\n<img src=\"https://user-images.githubusercontent.com/18453570/79851335-20993780-8400-11ea-988b-33018c526631.PNG\" alt=\"image\"></li>\n</ul>\n<h3 id=\"-synchronous-call--circuit-breaking--fault-isolation\"><a href=\"#-synchronous-call--circuit-breaking--fault-isolation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>· Synchronous Call / Circuit Breaking / Fault Isolation</h3>\n<ul>\n<li>Choice of circuit breaking framework: Implemented using Spring FeignClient + Hystrix option</li>\n</ul>\n<p>The scenario is implemented by linking the connection at courseRegistration-->payment with RESTful Request/Response, and if the payment request is excessive, fault isolation through CB.</p>\n<ul>\n<li>Set Hystrix: Set the CB circuit to close (fail and block requests quickly) when the processing time starts to exceed 610 millimeters in the request processing thread and is maintained for a certain amount.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># application.yml\n\nhystrix:\n  command:\n    # Global settings\n    default:\n      execution.isolation.thread.timeoutInMilliseconds: 610</code></pre>\n<ul>\n<li>Random load handling of the called service (payment) - fluctuates from 400 millimeters to 220 millimeters</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># (paymentSystem) PaymentSystem.java (Entity)\n\n    @PostPersist\n    public void onPostPersist(){  //Save the payment history and drag the appropriate time\n\n        ...\n        \n        try {\n            Thread.currentThread().sleep((long) (400 + Math.random() * 220));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }</code></pre>\n<ul>\n<li>\n<p>Check circuit breaker operation with load tester siege tool:</p>\n<ul>\n<li>100 concurrent users</li>\n<li>run for 120 seconds</li>\n<li>Excessive request triggers CB Block request</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/63028499/79851238-01020f00-8400-11ea-85fb-409dd5f9bfd6.PNG\" alt=\"image\"></p>\n<ul>\n<li>After some requests have been sent back, the previously delayed tasks have been processed, and the circuit is closed to start accepting requests again.\n<img src=\"https://user-images.githubusercontent.com/63028499/79851242-01020f00-8400-11ea-9cc9-fdd639a91ed8.PNG\" alt=\"image\"></li>\n<li>After that, as this pattern continues to repeat, the system operates well without domino effects or runaway resource consumption.\n<img src=\"https://user-images.githubusercontent.com/63028499/79851236-ffd0e200-83ff-11ea-9941-3e6038bbc89f.PNG\" alt=\"image\"></li>\n</ul>\n<ul>\n<li>The operating system does not die and shows that the resource is protected by properly opening and closing the circuit by CB continuously. However, since 66.62% of successes and 33.38% of failures are not good for customer usability, follow-up processing to expand the system through retry settings and dynamic scale out (automatic addition of replicas, HPA) is necessary.</li>\n<li>Confirm that availability is increased (siege)</li>\n</ul>\n<p><strong>autoscale out</strong></p>\n<p>Previously, CB made it possible to operate the system stably, but it did not accept 100% of the user's request.</p>\n<ul>\n<li>Configure HPA to dynamically increase replicas for payment services. The setting increases the number of replicas to 10 when CPU usage exceeds 15%:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl autoscale deploy pay --min=1 --max=10 --cpu-percent=15</code></pre>\n<ul>\n<li>Walk the workload for 2 minutes the way CB did.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">siege -c100 -t120S -r10 --content-type &quot;application/json&quot; &#39;http://52.231.118.204:8080/courseRegistrationSystems POST {&quot;lectureId&quot;: 1}&#39;</code></pre>\n<ul>\n<li>Monitor how autoscale is going:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl get deploy pay -w</code></pre>\n<ul>\n<li>After some time (about 30 seconds) you can see the scale out occurs:\n<img src=\"https://user-images.githubusercontent.com/63028499/79851254-02cbd280-8400-11ea-9c75-4d60ce42d54d.PNG\" alt=\"image\"></li>\n<li>If you look at the log of siege, you can see that the overall success rate has increased.\n<img src=\"https://user-images.githubusercontent.com/63028499/79851251-02cbd280-8400-11ea-96e7-ea092375e77d.PNG\" alt=\"image\"></li>\n</ul>\n<h3 id=\"-uninterrupted-redistribution\"><a href=\"#-uninterrupted-redistribution\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>· Uninterrupted redistribution</h3>\n<ul>\n<li>First, to check whether non-stop redistribution is 100%, the test is conducted in the presence of Readiness Probe and Autoscaler. As a result, it was confirmed that the uninterrupted redistribution was successful because the availability did not change during the distribution period at 100%.\n<img src=\"https://user-images.githubusercontent.com/18453570/79856578-79b89980-8407-11ea-9daf-697365e0a388.PNG\" alt=\"image\"></li>\n<li>After that, the change in availability was confirmed by testing with readiness and autoscaler removed. As a result, it can be seen that it has dropped to the 20% range.\n<img src=\"https://user-images.githubusercontent.com/18453570/79856571-79200300-8407-11ea-84a9-946f3a2a076d.PNG\" alt=\"image\"></li>\n</ul>\n","sidebar":"started","next":"","prev":"","headings":[{"depth":1,"value":"Internet lecture system","anchor":"#internet-lecture-system"},{"depth":2,"value":"service scenario","anchor":"#service-scenario"},{"depth":2,"value":"checkpoint","anchor":"#checkpoint"},{"depth":2,"value":"Analysis/Design","anchor":"#analysisdesign"},{"depth":3,"value":"· Event Storming result","anchor":"#-event-storming-result"},{"depth":3,"value":"· Hexagonal Architecture Diagram Derivation","anchor":"#-hexagonal-architecture-diagram-derivation"},{"depth":2,"value":"avatar","anchor":"#avatar"},{"depth":3,"value":"· Application of DDD","anchor":"#-application-of-ddd"},{"depth":3,"value":"· Synchronous Invocation and Fallback Handling","anchor":"#-synchronous-invocation-and-fallback-handling"},{"depth":3,"value":"· Asynchronous Invocation / Temporal Decoupling / Failure Isolation / Eventual Consistency Test","anchor":"#-asynchronous-invocation--temporal-decoupling--failure-isolation--eventual-consistency-test"},{"depth":2,"value":"operation","anchor":"#operation"},{"depth":3,"value":"· CI/CD settings","anchor":"#-cicd-settings"},{"depth":3,"value":"· Synchronous Call / Circuit Breaking / Fault Isolation","anchor":"#-synchronous-call--circuit-breaking--fault-isolation"},{"depth":3,"value":"· Uninterrupted redistribution","anchor":"#-uninterrupted-redistribution"}]},"allMarkdownPage":{"edges":[{"node":{"path":"/tool/setup-on-prem/","title":"Running on Docker Compose (with Github)"}},{"node":{"path":"/tool/si-gpt/","title":"Code Implementation with ChatGPT"}},{"node":{"path":"/tool/plsql-2-java/","title":"Legacy Modernizer"}},{"node":{"path":"/tool/on-prem-inst/","title":"Installing on-premise MSA-Easy"}},{"node":{"path":"/tool/pbc-marketplace/","title":"PBCs(Packaged Business Capabilities) for Composable Enterprise Implementation"}},{"node":{"path":"/tool/k8s-modeling/","title":"K8s Deployment Modeling"}},{"node":{"path":"/tool/on-prem-inst-gitea/","title":"On-Premises Installation Guide"}},{"node":{"path":"/tool/model-driven/","title":"Code Generation"}},{"node":{"path":"/tool/marketplace/","title":"Marketplace"}},{"node":{"path":"/tool/infrastructure-modeling/","title":"Infrastructure Modeling (Kubernetes)"}},{"node":{"path":"/tool/google-drive-examples/","title":"Google Drive Examples"}},{"node":{"path":"/tool/event-monitoring/","title":"Event Monitoring"}},{"node":{"path":"/tool/event-storming-tool/","title":"EventStorming"}},{"node":{"path":"/tool/development-practice/","title":"Registration Course"}},{"node":{"path":"/tool/ddl-to-eventstorming/","title":"DDL To EventStorming"}},{"node":{"path":"/tool/deepseek-ai/","title":""}},{"node":{"path":"/tool/cloud-ide-tool/","title":"Cloud IDE"}},{"node":{"path":"/tool/bc-domain-gen/","title":"Natural Language-based Bounded Context & Domain Design AI"}},{"node":{"path":"/tool/chat-gpt/","title":"Creating Models with ChatGPT"}},{"node":{"path":"/tool/aggregate-design/","title":"Aggregate Design"}},{"node":{"path":"/tool/attending-lectures/","title":"Attending lectures"}},{"node":{"path":"/templates-language/springboot-java-template/","title":"Spring Boot/Java Template"}},{"node":{"path":"/templates-language/python-template/","title":"Python template "}},{"node":{"path":"/templates-language/go-template/","title":"Go Template "}},{"node":{"path":"/started/key-features/","title":"Key Features"}},{"node":{"path":"/started/","title":"Introduction"}},{"node":{"path":"/started/domain-driven/","title":"Domain-Driven Design Learning"}},{"node":{"path":"/started/event-storming-learning/","title":"Event Storming Learning"}},{"node":{"path":"/operation/ops-deploy-diagramming-advanced-pvc/","title":"Persistent Volume"}},{"node":{"path":"/operation/ops-deploy-diagramming-advanced-istio/","title":"Istio Mesh"}},{"node":{"path":"/operation/ops-deploy-diagramming-basic-objects/","title":"12st Mall Basic Deploy"}},{"node":{"path":"/operation/ops-deploy-diagramming-advanced-hpa/","title":"Automatic Scaling (HPA) Deployment"}},{"node":{"path":"/operation/ops-deploy-diagramming-advanced-ingress/","title":"Ingress Deployment Model Design"}},{"node":{"path":"/info/pricing/","title":"Pricing"}},{"node":{"path":"/info/partnership/","title":"Partner Program"}},{"node":{"path":"/info/consulting/","title":"Consulting"}},{"node":{"path":"/example-scenario/library-system/","title":"library system"}},{"node":{"path":"/info/company/","title":"Cases"}},{"node":{"path":"/example-scenario/online-lecture/","title":"Internet lecture system"}},{"node":{"path":"/example-scenario/food-delivery/","title":"food delivery"}},{"node":{"path":"/example-scenario/animal-hospital/","title":"Veterinary Practice Management System"}},{"node":{"path":"/example-scenario/accommodation-reservation/","title":"AirBnB"}},{"node":{"path":"/development/pub-sub/","title":"Pub/Sub Integration"}},{"node":{"path":"/development/monolith-2-misvc/","title":"Request/Response Communication in MSA Integration"}},{"node":{"path":"/development/oauth2with-keycloak/","title":"JWT Token-based Authentication and Authorization"}},{"node":{"path":"/development/gateway/","title":"API Gateway"}},{"node":{"path":"/development/dp-cqrs/","title":"Data Projection with CQRS"}},{"node":{"path":"/development/choreography-saga/","title":"Choreography Saga"}},{"node":{"path":"/development/cna-start/","title":"Running Unit Microservices"}},{"node":{"path":"/custom-template/unit-test/","title":"Test Automation"}},{"node":{"path":"/custom-template/template-editor-custom-template/","title":"Creating Custom Templates in MSAEZ"}},{"node":{"path":"/custom-template/tutorial/","title":"Concept of Custom Template"}},{"node":{"path":"/custom-template/template-structure/","title":"Template File Structure"}},{"node":{"path":"/custom-template/template-editor/","title":"Template Editor"}},{"node":{"path":"/custom-template/helper/","title":"Helper"}},{"node":{"path":"/custom-template/loop-conditional-statement/","title":"Loop & Conditional Statement"}},{"node":{"path":"/custom-template/mock-server/","title":"Open API 3.0-based Mock Server Generation Topping(New)"}},{"node":{"path":"/custom-template/designing-template/","title":"Developing Custom Template"}},{"node":{"path":"/contact/question/","title":"CONTACT"}},{"node":{"path":"/business/eventstorming-fooddelivery/","title":"[이벤트스토밍] - DDD Food Delivery 예제"}},{"node":{"path":"/custom-template/global-helper/","title":"Global Helper"}},{"node":{"path":"/custom-template/custom-template/","title":"Custom Template Objects"}},{"node":{"path":"/business/","title":"Eventstorming - Shopping Mall"}},{"node":{"path":"/business/ddd-google-drive/","title":"[이벤트스토밍] - 구글 드라이브 예제"}}]}},"context":{}}