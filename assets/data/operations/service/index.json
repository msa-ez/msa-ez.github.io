{"hash":"fa5fedf1848133ded319caa58f5dc027d2a72899","data":{"markdownPage":{"id":"d6badbedd3a01182e28588d13bbb39eb","title":"12번가 마이크로서비스 라우터(Service) 생성","description":"","path":"/operations/service/","timeToRead":3,"content":"<h1 id=\"12번가-마이크로서비스-라우터service-생성\"><a href=\"#12%EB%B2%88%EA%B0%80-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%9D%BC%EC%9A%B0%ED%84%B0service-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>12번가 마이크로서비스 라우터(Service) 생성</h1>\n<h3 id=\"the-route-for-containers--service\"><a href=\"#the-route-for-containers--service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The Route for Containers : Service</h3>\n<p>쿠버네티스는 클러스터에 배포된 마이크로서비스별 컨테이너에 접속하기 위해 <strong>\"Service\"</strong> 객체를 제공한다. 이 Service로 접속하게 되면 연결된 컨테이너로 요청이 프락시된다. </p>\n<p>이번 랩에서는 이 Service에 대해 알아본다.</p>\n<ul>\n<li>마이크로서비스들의 라우터인 Serivce Scope에 대해 이해한다.</li>\n<li>마이크로서비스까지 요청이 전달되는 과정에 Kube Proxy의 역할에 대해 학습한다.</li>\n</ul>\n<h3 id=\"service-basic-template\"><a href=\"#service-basic-template\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Service basic template</h3>\n<pre class=\"language-text\"><code class=\"language-text\">  apiVersion: v1\n  kind: Service\n  metadata:\n    name: my-service\n  spec:\n    selector:\n      app: order\n    ports:\n      - protocol: TCP\n        port: 8080\n        targetPort: 8080\n    type: ClusterIP/NodePort/LoadBalancer\t\t</code></pre>\n<h3 id=\"대상-컨테이너-생성\"><a href=\"#%EB%8C%80%EC%83%81-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대상 컨테이너 생성</h3>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl create deploy order --image=ghcr.io/acmexii/order-liveness:latest            </code></pre>\n<h3 id=\"clusterip-type-service-생성\"><a href=\"#clusterip-type-service-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ClusterIP Type Service 생성</h3>\n<ul>\n<li>클러스터 내에서만 접근 가능한 라우터를 생성한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl expose deploy order --type=ClusterIP --port=8080 --target-port=8080\n# 생성된 ClusterIP 정보확인\nkubectl get service \n# Selector 확인\nkubectl get service order -o yaml</code></pre>\n<ul>\n<li>새로운 Terminal에서 클라이언트용 컨테이너를 생성하고 접속한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: siege\nspec:\n  containers:\n  - name: siege\n    image: apexacme/siege-nginx\nEOF</code></pre>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl exec -it siege -- /bin/bash</code></pre>\n<ul>\n<li>위에서 확인된 Order 서비스의 ClusterIP로  접근한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http http://10.x.x.x:8080</code></pre>\n<h3 id=\"nodeport-type-service-생성\"><a href=\"#nodeport-type-service-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NodePort Type Service 생성</h3>\n<ul>\n<li>워크 노드의 포트를 통해서도 접근 가능한 라우터를 다시 생성한다.  </li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl delete service order\nkubectl expose deploy order --type=NodePort --port=8080 --target-port=8080\n# 생성된 NodePort 정보확인\nkubectl get service </code></pre>\n<ul>\n<li>NodePort로 서비스 접근</li>\n<li>Order 컨테이너가 바인딩 된 Worker-Node를 확인한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl get pod -o wide</code></pre>\n<ul>\n<li>해당 워크노드의 Cluster IP를 통해 접근한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># Worker-Node IP 확인\nkubectl get nodes -o wide\n# siege 터미널에서 NodePort 접속\nhttp http://192.168.x.x:3xxxx</code></pre>\n<ul>\n<li>Order Pod가 바인딩 되지않은 다른 Worker-Node를 통해서도 접근해 본다.</li>\n<li>접근이 된다, 이유는</li>\n<li>라우터 생성시 모든 Node상에 있는 Kube-proxy Daemon이 Networking Rule 작업(Iptables 갱신)을 수행하므로 어느 Node로 접속해도 접근 가능하다. </li>\n<li>Rule 확인하기</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># AWS Console을 통해 EC2 &gt; Auto Scaling Group &gt; Work-Node에 SSH로 접근\n$ iptables -t nat -S | grep 8080</code></pre>\n<h3 id=\"loadbalancer-type-service-생성\"><a href=\"#loadbalancer-type-service-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LoadBalancer Type Service 생성</h3>\n<ul>\n<li>워크 노드의 포트 뿐만 아니라 클라우드 외부에서도 접근 가능한 라우터를 다시 생성한다.  </li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl delete service order\nkubectl expose deploy order --type=LoadBalancer --port=8080 --target-port=8080\n# 생성된 LoadBalancer 정보확인\nkubectl get service</code></pre>\n<ul>\n<li>LoadBalancer 엔드포인트로 서비스 접근</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># Order Service의 External-IP 복사   \n# Web Browser를 통한 접속</code></pre>\n<h3 id=\"kube-dns-a레코드를-통한-접근\"><a href=\"#kube-dns-a%EB%A0%88%EC%BD%94%EB%93%9C%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%A0%91%EA%B7%BC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kube-DNS A레코드를 통한 접근</h3>\n<pre class=\"language-text\"><code class=\"language-text\"># siege 터미널에서\nhttp http://order:8080</code></pre>\n<ul>\n<li>Kubernetes Cluster에서 서비스가 생성되면 Kube-DNS에 A레코드가 등록되고, 서비스가 삭제되면 A레코드 또한 자동 삭제한다.</li>\n<li>Kube-DNS 정보확인</li>\n<li>kubectl get service -n kube-system</li>\n<li>kubernetes는 컨테이너 생성시에 NameServer(Kube-DNS) 정보를 자동 Injection 한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">$ cat /etc/resolv.conf</code></pre>\n<ul>\n<li>마이크로서비스간 참조시, Service ClusterIP 또한 유동적이므로 Cluster 내에서는 '서비스 이름'으로 접근한다.</li>\n</ul>\n","sidebar":"started","next":"","prev":"","headings":[{"depth":1,"value":"12번가 마이크로서비스 라우터(Service) 생성","anchor":"#12번가-마이크로서비스-라우터service-생성"},{"depth":3,"value":"The Route for Containers : Service","anchor":"#the-route-for-containers--service"},{"depth":3,"value":"Service basic template","anchor":"#service-basic-template"},{"depth":3,"value":"대상 컨테이너 생성","anchor":"#대상-컨테이너-생성"},{"depth":3,"value":"ClusterIP Type Service 생성","anchor":"#clusterip-type-service-생성"},{"depth":3,"value":"NodePort Type Service 생성","anchor":"#nodeport-type-service-생성"},{"depth":3,"value":"LoadBalancer Type Service 생성","anchor":"#loadbalancer-type-service-생성"},{"depth":3,"value":"Kube-DNS A레코드를 통한 접근","anchor":"#kube-dns-a레코드를-통한-접근"}]},"allMarkdownPage":{"edges":[{"node":{"path":"/tool/marketplace/","title":"Template/Topping Marketplace"}},{"node":{"path":"/tool/infrastructure-modeling/","title":"Infrastructure Modeling (Kubernetes)"}},{"node":{"path":"/operations/istio-metric-based-hpa/","title":"[Service Mesh] Istio Metrics based HPA"}},{"node":{"path":"/development/ops-docker/","title":"Application Packaging with Container (Docker)"}},{"node":{"path":"/tool/google-drive-examples/","title":"Google Drive Examples"}},{"node":{"path":"/tool/on-prem-inst/","title":"Installing on-premise MSA-Easy"}},{"node":{"path":"/tool/event-storming-tool/","title":"EventStorming"}},{"node":{"path":"/tool/cloud-ide-tool/","title":"Cloud IDE"}},{"node":{"path":"/tool/development-practice/","title":"Registration Course"}},{"node":{"path":"/tool/attending-lectures/","title":"Attending lectures"}},{"node":{"path":"/operations/ops-persistence-volume-azure/","title":"파일공유를 위한 클라우드 스토리지 활용(Azure)"}},{"node":{"path":"/templates-language/python-template/","title":"Python template "}},{"node":{"path":"/templates-language/springboot-java-template/","title":"Spring Boot/Java Template"}},{"node":{"path":"/tool/chat-gpt/","title":"Chat GPT-based Model Generation"}},{"node":{"path":"/templates-language/go-template/","title":"Go Template "}},{"node":{"path":"/operations/service/","title":"12번가 마이크로서비스 라우터(Service) 생성"}},{"node":{"path":"/operations/ops-utility/","title":"쿠버네티스 유틸리티"}},{"node":{"path":"/operations/service-mesh-ab-testing/","title":"Istio based A/B testing 배포"}},{"node":{"path":"/operations/ops-service-mesh-istio-2/","title":"[Service Mesh] Istio-2"}},{"node":{"path":"/operations/ops-persistence-volume/","title":"파일시스템 (볼륨) 연결과 데이터베이스 설정"}},{"node":{"path":"/operations/ops-service-mesh-istio/","title":"[Service Mesh] Istio"}},{"node":{"path":"/operations/ops-readiness/","title":"셀프힐링 & 무정지 배포 실습"}},{"node":{"path":"/operations/ops-pod-status/","title":"Pod 상태값에 따른 마이크로서비스 트러블 슈팅"}},{"node":{"path":"/operations/ops-persistence-volume-efs/","title":"파일공유를 위한 NAS 스토리지 생성과 설정"}},{"node":{"path":"/operations/ops-persistence-volume-gcp/","title":"파일공유를 위한 클라우드 스토리지 활용(GCP)"}},{"node":{"path":"/operations/ops-liveness/","title":"셀프힐링 실습"}},{"node":{"path":"/operations/ops-ingress-virtualhost/","title":"Ingress - Virtual Host based"}},{"node":{"path":"/operations/ops-label-annotation/","title":"Labels and Annotations"}},{"node":{"path":"/operations/ops-kubernetes/","title":"Kubernetes Basic Command"}},{"node":{"path":"/operations/ops-ingress/","title":"Ingress 를 통한 진입점 통일 - Path-based routing"}},{"node":{"path":"/operations/ops-aws-setting/","title":"AWS Cloud Setup(EKS, ECR 설정)"}},{"node":{"path":"/operations/ops-configmap/","title":"Kubernetes에 환경변수 구성하기"}},{"node":{"path":"/operations/ops-deploy-my-app/","title":"애플리케이션 패키징,도커라이징,클러스터 배포"}},{"node":{"path":"/operations/ops-aws-csi-setting/","title":"AWS Cloud Setup(Container Storage Interface)"}},{"node":{"path":"/operations/ops-autoscale/","title":"Pod Auto Scaling"}},{"node":{"path":"/operations/ops-argo-rollout-canary-istio/","title":"[GitOps] Argo Rollout 와 Istio 를 통한 카나리 배포"}},{"node":{"path":"/operations/ops-anatomy-kubernetes/","title":"쿠버네티스 내부구조 분석"}},{"node":{"path":"/operations/microservice-logging2/","title":"마이크로서비스 통합 로깅 with Loki stack"}},{"node":{"path":"/operations/istio-sre-monitoring/","title":"Service Reliability Engineering"}},{"node":{"path":"/operations/microservice-logging/","title":"마이크로서비스 통합 로깅 with EFK stack"}},{"node":{"path":"/operations/istio-traffic/","title":"[Service Mesh] Istio 를 통한 동적 트래픽 라우팅"}},{"node":{"path":"/operations/k8s-monitoring/","title":"MSA 모니터링 with installing Grafana"}},{"node":{"path":"/operations/istio-resiliency-part2/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part2 - 서킷브레이커"}},{"node":{"path":"/operations/istio-msa-telemetry/","title":"[Service Mesh] MSA 모니터링 w/ Istio addon Grafana"}},{"node":{"path":"/operations/istio-resiliency-part1/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part1 - 타임아웃/재시도"}},{"node":{"path":"/started/domain-driven/","title":"Domain-Driven Design Learning"}},{"node":{"path":"/operations/end-to-end/","title":"12번가 전체 마이크로서비스의 배포"}},{"node":{"path":"/operations/apply-security-to-12st-mall/","title":"12번가 Mall에 토큰인증 적용하기"}},{"node":{"path":"/started/event-storming-learning/","title":"Event Storming Learning"}},{"node":{"path":"/operations/gitops-argo-cd/","title":"[GitOps] Argo CD 를 통한 카나리 배포"}},{"node":{"path":"/operations/azure/","title":"Azure Cloud Setup (AKS, ACR 설정)"}},{"node":{"path":"/started/","title":"Introduction"}},{"node":{"path":"/development/kafka-connect/","title":"CDC(Change Data Capture) with Kafka"}},{"node":{"path":"/custom-template/unit-test/","title":"Unit Test Creation Topping(New)"}},{"node":{"path":"/custom-template/mock-server/","title":"Open API 3.0-based Mock Server Generation Topping(New)"}},{"node":{"path":"/custom-template/tutorial/","title":"Concept of Custom Template"}},{"node":{"path":"/example-scenario/animal-hospital/","title":"Veterinary Practice Management System"}},{"node":{"path":"/example-scenario/food-delivery/","title":"food delivery"}},{"node":{"path":"/custom-template/designing-template/","title":"Developing Custom Template"}},{"node":{"path":"/example-scenario/accommodation-reservation/","title":"AirBnB"}},{"node":{"path":"/example-scenario/online-lecture/","title":"Internet lecture system"}},{"node":{"path":"/custom-template/custom-template/","title":"Custom Template Objects"}},{"node":{"path":"/example-scenario/library-system/","title":"library system"}},{"node":{"path":"/development/pubsub-idempotency/","title":"Pub/Sub Communication - Choreography with Idempotency"}},{"node":{"path":"/development/understanding-jpa-based-single-microservice/","title":"Understanding JPA Based Single Microservice"}},{"node":{"path":"/development/token-based-auth/","title":"JWT Token-based Authorization"}},{"node":{"path":"/development/pub-sub/","title":"Pub/Sub Communication"}},{"node":{"path":"/development/orchestration-saga/","title":"Orchestration Saga with Axon Framework"}},{"node":{"path":"/development/pubsub-deadline/","title":"Pub/Sub Communication - Choreography with Deadline added"}},{"node":{"path":"/development/oauth2with-keycloak/","title":"JWT Token-based Authorization - Advanced"}},{"node":{"path":"/development/monolith-2-misvc/","title":"MSA Communication by Req/Res"}},{"node":{"path":"/development/kafka-scaling/","title":"Kafka Scaling "}},{"node":{"path":"/development/kafka-scaling-concurrenty-handling/","title":"Kafka scaling & Concurrenty handling"}},{"node":{"path":"/development/kafka-retry-dlq/","title":"Kafka Retry & Dead Letter Queue "}},{"node":{"path":"/development/dp-frontend/","title":"Data Projection with Frontend and HATEOAS"}},{"node":{"path":"/development/kafka-basic/","title":"Kafka Basic Commands"}},{"node":{"path":"/development/gateway/","title":"API Gateway"}},{"node":{"path":"/development/conteact-messaging/","title":"Conteact Test by Message-based CDC"}},{"node":{"path":"/business/eventstorming-fooddelivery/","title":"Food Delivery Example"}},{"node":{"path":"/development/dp-graphql/","title":"Data Projection with GraphQL"}},{"node":{"path":"/development/contract-test/","title":"Contract Test (Consumer Driven Test)"}},{"node":{"path":"/development/dp-cqrs/","title":"Data Projection with CQRS"}},{"node":{"path":"/development/compensation-correlation/","title":"Pub/Sub Communication - Compensation & Correlation"}},{"node":{"path":"/development/choreography-saga/","title":"Choreography Saga with Axon Framework"}},{"node":{"path":"/development/cna-start/","title":"Running Microservice Units"}},{"node":{"path":"/development/circuit-breaker/","title":"Circuit Breaker for Req/Res"}},{"node":{"path":"/contact/question/","title":"CONTACT"}},{"node":{"path":"/business/ddd-google-drive/","title":"Google Drive Example"}},{"node":{"path":"/business/","title":"Shopping Mall Example"}}]}},"context":{}}